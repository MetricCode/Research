# SQL Fundamentals And Injection
## @Author : M3tr1c_r00t
### SQL injection (SQLi) 
![image](https://user-images.githubusercontent.com/99975622/227584831-9d987761-fd95-49d8-a457-5c259881399f.png)

is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. 
It generally allows an attacker to view data that they are not normally able to retrieve.
Many cases, an attacker can modify or delete this data, causing persistent changes to the application’s content or behavior.

#### SQL injection examples
SQL injection examples include:
- __Retrieving hidden data__, where you can modify a SQL query to return additional results.
- __Subverting application logic__, where you can change a query to interfere with the application’s logic.
- __UNION attacks__, where you can retrieve data from different database tables.
Examining the database, where you can extract information about the version and structure of the database.
- __Blind SQL injection__, where the results of a query you control are not returned in the application’s responses


#### 1). Retrieving hidden data
Consider a shopping application that displays products in different categories. When the user clicks on the Gifts category, their browser requests the URL:
```
https://insecure-website.com/products?category=Gifts
```
The sql request probably looks like this:
```
SELECT * FROM products WHERE category = ‘Gifts’ AND released = 1
```
This sql payload is going to give us all the products in the category of gifts and those that are released.

The restriction released = 1 is being used to hide products that are not released. For unreleased products, presumably released = 0.

Since there is no filtering going on, we can try to attack the server like this:
```
https://insecure-website.com/products?category=Gifts’--
```
This results in the SQL query:
```
SELECT * FROM products WHERE category = ‘Gifts’ OR 1=1—’ AND released = 1
```
Hence, this will return all the gifts, both released and unreleased.
#### 2). Subverting application logic
This is the most common one that we encounter when testing login pages.

So in a login page, consider the following SQL query:
```
SELECT * FROM users WHERE username = ‘wiener’ AND password = ‘bluecheese’
```

If there is no data filtering going on, we can actually send in the value of password empty and then comment out the password validation.
```
SELECT * FROM users WHERE username = 'administrator' --' AND password = ''
```
And we will get logged in as the administrator user.

#### 3). Retrieving data from other database tables(UNION based SQLi)
In this type of attack, we can read data from different tables within the database. We can read data from different tables in the databases.

For example, if an application executes the following query containing the user input “Gifts”:
```
SELECT name, description FROM products WHERE category = ‘Gifts’
```
Then an attacker can submit the input:
```
UNION SELECT username, password FROM users
```
This will return all usernames and passwords along with the names and descriptions of products.
#### 4). Blind SQL injection vulnerabilities
In this, the application does not return the results of the SQL query or the details of any database errors within its responses.
It is way harder to exploit due to the use of complex payloads.

Depending on the nature of the vulnerability and the database involved, the following techniques can be used to exploit blind SQL injection vulnerabilities:
- Change the logic of the query to trigger a detectable difference in the application’s response depending on the truth of a single condition. This might involve injecting a new condition into some Boolean logic, or conditionally triggering an error such as a divide-by-zero.
- Conditionally trigger a time delay in the processing of the query(Time Based Attack), allowing you to infer the truth of the condition based on the time that the application takes to respond.
- You can trigger an out-of-band network interaction, using OAST techniques. This technique is extremely powerful and works in situations where the other techniques do not. Often, you can directly exfiltrate data via the out-of-band channel, for example by placing the data into a DNS lookup for a domain that you control.

#### 5). Examining the database
You can query the version details for the database. The way that this is done depends on the database type, so you can infer the database type from whichever technique works. 
For example, on Oracle you can execute:
```
SELECT * FROM v$version
```
You can also determine what database tables exist, and which columns they contain. 

For example, on most databases you can execute the following query to list the tables:
```
SELECT * FROM information_schema.tables
```

#### SQL injection in different parts of the query
Most SQL injection vulnerabilities arise within the WHERE clause of a SELECT query. 

The most common other locations where SQL injection arises are:
- In UPDATE statements, within the updated values or the WHERE clause.
- In INSERT statements, within the inserted values.
- In SELECT statements, within the table or column name.
- In SELECT statements, within the ORDER BY clause.

### SQL Injection In Different Contexts
Note that you can perform an sql injection using any controllable input.

For example, in json or xml format which can be used to query the database.

These different formats may even provide alternative ways for you to obfuscate attacks that are otherwise blocked due to WAFs and other defense mechanisms. Weak implementations often just look for common SQL injection keywords within the request, so you may be able to bypass these filters by simply encoding or escaping characters in the prohibited keywords. For example, the following XML-based SQL injection uses an XML escape sequence to encode the S character in SELECT:

```
<stockCheck>
    <productId>
        123
    </productId>
    <storeId>
        999 &#x53;ELECT * FROM information_schema.tables
    </storeId>
</stockCheck>
```
This will be decoded before being passed onto the sql interpreter.

### Types of SQLi 
![image](https://user-images.githubusercontent.com/99975622/227712174-fb44d73c-bd76-4822-a3b7-6db6e88cd016.png)

#### i). In-Band SQLi
The attacker uses the same channel of communication to launch their attacks and to gather their results. In-band SQLi’s simplicity and efficiency make it one of the most common types of SQLi attack. 

In simple cases, the output of both the intended and the new query may be printed directly on the front end, and we can directly read it

There are two sub-variations of this method:

##### a). Error-based SQLi
The attacker performs actions that cause the database to produce error messages. The attacker can potentially use the data provided by these error messages to gather information about the structure of the database.
 it is used when we can get the PHP or SQL errors in the front-end, and so we may intentionally cause an SQL error that returns the output of our query.
##### b). Union-based SQLi
This technique takes advantage of the UNION SQL operator, which fuses multiple select statements generated by the database to get a single HTTP response. This response may contain data that can be leveraged by the attacker.

 We may also have to specify the exact location, 'i.e., column', which we can read, so the query will direct the output to be printed there. 

#### ii). Inferential (Blind) SQLi
In more complicated cases, we may not get the output printed, so we may utilize SQL logic to retrieve the output character by character.

The attacker sends data payloads to the server and observes the response and behavior of the server to learn more about its structure. This method is called blind SQLi because the data is not transferred from the website database to the attacker, thus the attacker cannot see information about the attack in-band.

Blind SQL injections can be classified as follows:

- Boolean — that attacker sends a SQL query to the database prompting the application to return a result. The result will vary depending on whether the query is true or false. Based on the result, the information within the HTTP response will modify or stay unchanged. The attacker can then work out if the message generated a true or false result.
- Time-based — attacker sends a SQL query to the database, which makes the database wait (for a period in seconds) before it can react. The attacker can see from the time the database takes to respond, whether a query is true or false. Based on the result, an HTTP response will be generated instantly or after a waiting period. The attacker can thus work out if the message they used returned true or false, without relying on data from the database.

#### iii). Out-of-band SQLi
The attacker can only carry out this form of attack when certain features are enabled on the database server used by the web application. This form of attack is primarily used as an alternative to the in-band and inferential SQLi techniques.

They are performed when the attacker can’t use the same channel to launch the attack and gather information, or when a server is too slow or unstable for these actions to be performed. These techniques count on the capacity of the server to create DNS or HTTP requests to transfer data to an attacker.

### **__NB__**
#### Second-order SQL injection
__First-order SQL injection__ arises where the application takes user input from an HTTP request and, in the course of processing that request, incorporates the input into a SQL query in an unsafe way.

In second-order SQL injection (also known as stored SQL injection), the application takes user input from an HTTP request and stores it for future use. This is usually done by placing the input into a database, but no vulnerability arises at the point where the data is stored. Later, when handling a different HTTP request, the application retrieves the stored data and incorporates it into a SQL query in an unsafe way.

## Encoding Bypass
![image](https://user-images.githubusercontent.com/99975622/227712500-c7558180-b36b-4e51-975c-adf4996e1136.png)

__**Note**__: in sql, 'and' is executed first then 'or'
### SQLi Comments
 Comments are used to document queries or ignore a certain part of the query. We can use two types of line comments with MySQL -- and #, in addition to an in-line comment /**/ (though this is not usually used in SQL injections).
 
The -- can be used as follows:

```
 mysql> SELECT username FROM logins; -- Selects usernames from the logins table 

+---------------+
| username      |
+---------------+
| admin         |
| administrator |
| john          |
| tom           |
+---------------+
4 rows in set (0.00 sec)
 ```
 There has to be an empty space after them, so the comment starts with (-- ), with a space at the end.
 
 This is sometimes URL encoded as (--+), as spaces in URLs are encoded as (+). To make it clear, we will add another (-) at at the end (-- -), to show the use of a space character.
 
 #### Using the # symmbol
 ```
 mysql> SELECT * FROM logins WHERE username = 'admin'; # You can place anything here AND password = 'something'

+----+----------+----------+---------------------+
| id | username | password | date_of_joining     |
+----+----------+----------+---------------------+
|  1 | admin    | p@ssw0rd | 2020-07-02 00:00:00 |
+----+----------+----------+---------------------+
1 row in set (0.00 sec)
 ```
 __Note__: if you are inputting your payload in the URL within a browser, a (#) symbol is usually considered as a tag, and will not be passed as part of the URL. In order to use (#) as a comment within a browser, we can use '%23', which is an URL encoded (#) symbol.
 
 <br>
 SQL supports the usage of parenthesis if the application needs to check for particular conditions before others. Expressions within the parenthesis take precedence over other operators and are evaluated first.
 
![image](https://user-images.githubusercontent.com/99975622/227713029-ac5cc154-045b-4ada-b0b0-bc3c36e1ac29.png)
The above query ensures that the user's id is always greater than 1, which will prevent anyone from logging in as admin. Additionally, we also see that the password was hashed before being used in the query. This will prevent us from injecting through the password field because the input is changed to a hash.

<br>
Logging in as the user with an id not equal to 1 was successful. So, how can we log in as the admin? We know from the previous section on comments that we can use them to comment out the rest of the query.

<br>
To execute the query successfully, we will have to add a closing parenthesis. Let us try using the username admin')-- to close and comment out the rest.

![image](https://user-images.githubusercontent.com/99975622/227713207-d2829858-ec8f-451a-a8e5-af153408be29.png)
```
SELECT * FROM logins where (username='admin')

```

#### Union Clause
The Union clause is used to combine results from multiple SELECT statements. This means that through a UNION injection, we will be able to SELECT and dump data from all across the DBMS, from multiple tables and databases. 

First, let us see the content of the ports table:
```  
mysql> SELECT * FROM ports;

+----------+-----------+
| code     | city      |
+----------+-----------+
| CN SHA   | Shanghai  |
| SG SIN   | Singapore |
| ZZ-21    | Shenzhen  |
+----------+-----------+
3 rows in set (0.00 sec)
```
Next, let us see the output of the ships tables:
```  
mysql> SELECT * FROM ships;

+----------+-----------+
| Ship     | city      |
+----------+-----------+
| Morrison | New York  |
+----------+-----------+
1 rows in set (0.00 sec)
```
Now, let us try to use UNION to combine both results:
```  
mysql> SELECT * FROM ports UNION SELECT * FROM ships;

+----------+-----------+
| code     | city      |
+----------+-----------+
| CN SHA   | Shanghai  |
| SG SIN   | Singapore |
| Morrison | New York  |
| ZZ-21    | Shenzhen  |
+----------+-----------+
4 rows in set (0.00 sec)
```
As we can see, UNION combined the output of both SELECT statements into one, so entries from the ports table and the ships table were combined into a single output with four rows. As we can see, some of the rows belong to the ports table while others belong to the ships table.

__Note:__ The data types of the selected columns on all positions should be the same.

We can inject a UNION query into the input, such that rows from another table are returned:

```
SELECT * from products where product_id = '1' UNION SELECT username, password from passwords-- '
```
The above query would return username and password entries from the passwords table, assuming the products table has two columns.

## Sources
```
https://github.com/payloadbox/sql-injection-payload-list
https://book.hacktricks.xyz/pentesting-web/sql-injection
https://www.invicti.com/blog/web-security/sql-injection-cheat-sheet/
```

## My socials:
<br>@ twitter: https://twitter.com/M3tr1c_r00t
<br>@ instagram: https://instagram.com/m3tr1c_r00t/
