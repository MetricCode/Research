# Cross Site Scripting
## @Author : M3tr1c_r00t
![xss](https://user-images.githubusercontent.com/99975622/226171062-8599d63a-9952-4084-bf25-259dae50370b.jpg)

### Overview
Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted websites

Cross-site scripting works by manipulating a vulnerable web site so that it returns malicious JavaScript to users. When the malicious code executes inside a victim’s browser, the attacker can fully compromise their interaction with the application.

It’s long been common practice to use the alert() function for this purpose because it’s short, harmless, and pretty hard to miss when it’s successfully called. In fact, you solve the majority of our XSS labs by invoking alert() in a simulated victim’s browser.

Unfortunately, there’s a slight hitch if you use Chrome. From version 92 onward (July 20th, 2021), cross-origin iframes are prevented from calling alert(). As these are used to construct some of the more advanced XSS attacks, you’ll sometimes need to use an alternative PoC payload. In this scenario, we recommend the print() function. If you’re interested in learning more about this change and why we like print(), check out our blog post on the subject.

### Types of XSS Attacks
- Reflected XSS
- Stored XSS
- DOM-based XSS
- Blind XSS


#### 1). Reflected XSS
This is where the injected script is reflected off the web server, such as in an error message, search result, or any other response that includes some or all of the input sent to the server as part of the request.
It is the simplest variety of cross-site scripting. 

It arises when an application receives data in an HTTP request and includes that data within the immediate response in an unsafe way.

Here is a simple example of a reflected XSS vulnerability:
```
https://insecure-website.com/status?message=All+is+well.
<p>Status: All is well.</p>

```
The application doesn’t perform any other processing of the data, so an attacker can easily construct an attack like this:

```
https://insecure-website.com/status?message=<script>/*+Bad+stuff+here...+*/</script>
<p>Status: <script>/* Bad stuff here... */</script></p>

```
#### 2). Stored XSS
Is also known as persistent or second-order XSS

This arises when an application receives data from an untrusted source and includes that data within its later HTTP responses in an unsafe way.

The data in question might be submitted to the application via HTTP requests; for example, comments on a blog post, user nicknames in a chat room, or contact details on a customer order. 

In other cases, the data might arrive from other untrusted sources; for example, a webmail application displaying messages received over SMTP, a marketing application displaying social media posts, or a network monitoring application displaying packet data from network traffic.


Here is a simple example of a stored XSS vulnerability. 

A message board application lets users submit messages, which are displayed to other users:

```
<p>Hello, this is my message!</p>
```

Since the application doesn’t perform any other processing, we can execute code:

```
<p><script>/* Bad stuff here... */</script></p>
```

#### 3). DOM XSS
This arises when an application contains some client-side JavaScript that processes data from an untrusted source in an unsafe way, usually by writing the data back to the DOM.

In the following example, an application uses some JavaScript to read the value from an input field and write that value to an element within the HTML:
```
Var search = document.getElementById(‘search’).value;
Var results = document.getElementById(‘results’);
Results.innerHTML = ‘You searched for: ‘ + search;
```

If the we can control the value of the input field, we can make our own payload/script to execute:
```
You searched for: <img src=1 onerror=’/* Bad stuff here... */’>
```

#### 4). Blind XSS
Is a form of persistent XSS.

This occurs when the attacker’s payload saved on the server and reflected back to the victim from the backend application.

For example in forms and message panels.

In this case, the payload in the form will be exxecuted when being looked at and even at times when being submitted onto the server.


Blind Cross-site Scripting is hard to confirm in the real-world scenario but one of the best tools for this is XSS Hunter.

### How to find and test for XSS vulnerabilities
- Manually testing for reflected and stored XSS normally involves submitting some simple unique input (such as a short alphanumeric string) into every entry point in the application, identifying every location where the submitted input is returned in HTTP responses, and testing each location individually to determine whether suitably crafted input can be used to execute arbitrary JavaScript. In this way, you can determine the context in which the XSS occurs and select a suitable payload to exploit it.

- Manually testing for DOM-based XSS arising from URL parameters involves a similar process: placing some simple unique input in the parameter, using the browser’s developer tools to search the DOM for this input, and testing each location to determine whether it is exploitable. However, other types of DOM XSS are harder to detect. To find DOM-based vulnerabilities in non-URL-based input (such as document.cookie) or non-HTML-based sinks (like setTimeout), there is no substitute for reviewing JavaScript code, which can be extremely time-consuming. Burp Suite’s web vulnerability scanner combines static and dynamic analysis of JavaScript to reliably automate the detection of DOM-based vulnerabilities.


### Patching/Preventing XSS Attacks
- Filter input on arrival. At the point where user input is received, filter as strictly as possible based on what is expected or valid input.
- Encode data on output. At the point where user-controllable data is output in HTTP responses, encode the output to prevent it from being interpreted as active content. Depending on the output context, this might require applying combinations of HTML, URL, JavaScript, and CSS encoding.
- Use appropriate response headers. To prevent XSS in HTTP responses that aren’t intended to contain any HTML or JavaScript, you can use the Content-Type and X-Content-Type-Options headers to ensure that browsers interpret the responses in the way you intend.
- Content Security Policy. As a last line of defense, you can use Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities that still occur.

### XSS Payloads
#### 1). HTML Snippets
```
<title>Example document: %(title)</title>
```
Is intended to illustrate a template snippet that, if the variable title has value Cross-Site Scripting, results in the following HTML to be emitted to the browser:
```
<title>Example document: XSS Doc</title>
```
#### 2). Search Field
 
```
Example 2.
Suppose there’s a URL on Google’s site, http://www.google.com/search?q=flowers
```
, which returns 
HTML documents containing the fragment
```
<p>Your search for ‘flowers’ returned the following results:</p>
```

The value of the query parameter q is inserted into the page returned by Google. Suppose further that the data is not validated, filtered or escaped. 
Evil.org could put up a page that causes the following URL to be loaded in the browser (e.g., in an invisible<iframe>):

  ```
http://www.google.com/search?q=flowers+%3Cscript%3Eevil_script()%3C/script%3E
```
So the payload will be :
```
<p>Your search for ‘flowers <script>evil_script()</script>’
 ```
#### 3). Onload,onmousehover,onerror.
  
XSS attacks may be conducted without using <script>...</script> tags. 
 
#### Onload
```
<body onload=alert(‘test1’)> 
```
#### Onmouseover
```
 <b onmouseover=alert(‘Wufff!’)>click me!</b>
```
#### Onerror
```
<img src=http://url.to.file.which/not.exist onerror=alert(document.cookie);>
```
 
#### 4). XSS Using Script Via Encoded URI Schemes
If we need to hide against web application filters we may try to encode string characters, e.g.: a=&\#X41 (UTF-8) and use it in IMG tags:
```
<IMG SRC=j&#X41vascript:alert(‘test2’)>
```

#### 5). XSS Using Code Encoding
We may encode our script in base64 and place it in META tag. This way we get rid of alert() totally. More information about this method can be found in RFC 2397
```
<META HTTP-EQUIV=”refresh”
CONTENT=”0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg”>
```
### Sources
```
  https://hackr.io/blog/xss-cheat-sheet
  https://chawdamrunal.medium.com/xss-cheat-sheet-e8b8261963c9
```
  
## My socials:
<br>@ twitter: https://twitter.com/M3tr1c_root
<br>@ instagram: https://instagram.com/m3tr1c_r00t/
