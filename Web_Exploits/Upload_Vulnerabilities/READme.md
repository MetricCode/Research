We will cover:

-   Overwriting existing files on a server
-   Uploading and Executing Shells on a server      
-   Bypassing Client-Side filtering
-   Bypassing various kinds of Server-Side filtering
-   Fooling content type validation checks

## Overwriting Existing Files
Note that Web pages, for example, should not be writeable to the web user, thus preventing them from being overwritten with a malicious version uploaded by an attacker.

Let's say we know where the files are being uploaded such as images/ and there is no rename functionality.

If we know the name of a present file, we can have our own file with the same name and upload it to overwrite the existing file present.

###  Uploading and Executing Shells on a server 

With this we can get an RCE on the web-server. 

Remote code execution via an upload vulnerability in a web application tends to be exploited by uploading a program written in the same language as the back-end of the website (or another language which the server understands and will execute).

Traditionally this would be PHP, however, in more recent times, other back-end languages have become more common (Python Django and Javascript in the form of Node.js being prime examples

There are two basic ways to achieve RCE on a webserver when exploiting a file upload vulnerability: webshells, and reverse/bind shells

Realistically a fully featured reverse/bind shell is the ideal goal for an attacker; however, a webshell may be the only option available (for example, if a file length limit has been imposed on uploads, or if firewall rules prevent any network-based shells). We'll take a look at each of these in turn. As a general methodology, we would be looking to upload a shell of one kind or another, then activating it, either by navigating directly to the file if the server allows it (non-routed applications with inadequate restrictions), or by otherwise forcing the webapp to run the script for us (necessary in routed applications).


Let's say  a site upload doesnt check for the file type and there is no rename, we can upload a web-shell or reverse-shell script(from Github).

```
<?php system($_GET['cmd']); ?>
```


### Bypassing filtering

####  Client-Side filtering
When we talk about a script being "Client-Side", in the context of web applications, we mean that it's running in the user's browser as opposed to on the web server itself. For example js.

But since it happening on our side, it is fairly easy to bypass.

##### Ways to Bypass

- Turn of js on your browser
- Intercept and modify the incoming page - Using Burpsuite, we can intercept the incoming web page and strip out the Javascript filter before it has a chance to run.
- Intercept and modify the file upload - this method allows the web page to load as normal, but intercepts the file upload after it's already passed (and been accepted by the filter).
- Send the file directly to the upload point - we can do this using curl. To use this method you would first aim to intercept a successful upload (using Burpsuite or the browser console) to see the parameters being used in the upload, which can then be slotted into the above command.


####  Server-Side filtering
Server-side filtering tends to be more difficult to bypass, as you don't have the code in front of you. As the code is executed on the server, in most cases it will also be impossible to bypass the filter completely; instead we have to form a payload which conforms to the filters in place, but still allows us to execute our code.

If we have the source code it would be way better but it isnt that easy.
we can actually bypass the extension filtering by trying:
- file.jpg.php - trying double extension if the code is only detecting the contents after a period.(pathinfo function)
- Trying the different extensions for php such as php1-7, phtml, phar etc.

##### Ways to Bypass
- Extension Filtering
- Magic numbers - 


#### Types of Filtering

##### Extension Validation
File extensions identify the contents of a file. In practice they are very easy to change, so actually don't mean much; however, MS Windows still uses them to identify file types. 

In this case, the filters may either:
- They either blacklist extensions (i.e. have a list of extensions which are not allowed)
- They whitelist extensions (i.e. have a list of extensions which are allowed, and reject everything else).

##### File Type Filtering
Similar to Extension validation, but more intensive, file type filtering looks, once again, to verify that the contents of a file are acceptable to upload.

Types of file type validation:
- _MIME validation:_ MIME (**M**ultipurpose **I**nternet **M**ail **E**xtension) types are used as an identifier for files -- originally when transfered as attachments over email, but now also when files are being transferred over HTTP(S). MIME is based on the extension of the file, hence is extremely easy to bypass.
- __Magic Number validation__: The "magic number" of a file is a string of bytes at the very beginning of the file content which identify the content. For example, a PNG file would have these bytes at the very top of the file: `89 50 4E 47 0D 0A 1A 0A`. They can easily be faked.(Mostly used by linux/unix systems)

##### File Length Filtering
Are used to prevent huge files from being uploaded to the server via an upload form (as this can potentially starve the server of resources). It's worth bearing in mind that if an upload form only expects a very small file to be uploaded, there may be a length filter in place to ensure that the file length requirement is adhered to. As an example, our fully fledged PHP reverse shell from the previous task is 5.4Kb big -- relatively tiny, but if the form expects a maximum of 2Kb then we would need to find an alternative shell to upload.

##### File Name Filtering

Files uploaded to a server should be unique. Usually this would mean adding a random aspect to the file name, however, an alternative strategy would be to check if a file with the same name already exists on the server, and give the user an error if so. Additionally, file names should be sanitised on upload to ensure that they don't contain any "bad characters", which could potentially cause problems on the file system when uploaded (e.g. null bytes or forward slashes on Linux, as well as control characters such as `;` and potentially unicode characters). What this means for us is that, on a well administered system, our uploaded files are unlikely to have the same name we gave them before uploading, so be aware that you may have to go hunting for your shell in the event that you manage to bypass the content filtering.

##### File Content Filtering

More complicated filtering systems may scan the full contents of an uploaded file to ensure that it's not spoofing its extension, MIME type and Magic Number.

